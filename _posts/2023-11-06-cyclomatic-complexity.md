---
title: Метрики кода. Цикломатическая сложность
date: 2023-11-06 10:39:00 +0300
categories: [Разработка ПО, Метрики кода]
---

Первая статья из серии про метрики программного кода.

Метрики программного кода - это числовые индикаторы, используемые для измерения различных аспектов качества и характеристик программного кода. 
Они предоставляют информацию о структуре, сложности, поддерживаемости и других свойствах кода.

Метрики кода являются важным инструментом для разработчиков и команд разработки программного обеспечения, 
так как они помогают оценить и контролировать качество кода, выявлять и устранять проблемы, 
а также принимать обоснованные решения по оптимизации и улучшению кодовой базы. Кроме того, они могут выступать как параметры для сравнения результата рефакторинга некоторого компонента, например, в формате "Было-стало".

Метрики программного кода широко используются во многих областях разработки программного обеспечения. Например, они могут быть использованы для оценки качества кода перед релизом, анализа сложности алгоритмов, оптимизации производительности, обнаружения кодовых дефектов и повышения понимания кодовой базы новыми разработчиками.

Существует множество различных метрик и классов метрик программного кода.
Одна из самых распространенных - цикломатическая сложность. Она изначально была предложена Томасом Маккейбом в 1976 году и с тех пор широко применяется в инженерии программного обеспечения.
В данной статье рассмотрим именно эту метрику.

**Итак,** 

**Цикломатическая сложность** — это числовое измерение количества линейно независимых путей через исходный код программы. Эта метрика была введена Томасом Маккейбом в 1976 году и с тех пор выступает в качестве мощного инструмента для измерения сложности программ.

Цикломатическая сложность исчисляется на основе структуры управления программы. Каждый раз, когда встречается точка принятия решения в коде (например, операторы if/else, switch, while и так далее), цикломатическая сложность увеличивается. Программа без ветвлений будет иметь цикломатическую сложность 1, так как существует только один возможный путь через код.

Есть несколько преимуществ использования цикломатической сложности. Она помогает:

- Оценить сложность кода. Более высокое значение указывает на более сложный код, что, в свою очередь, может указывать на необходимость рефакторинга для упрощения.

- Планировать тестирование. Величина цикломатической сложности определяет минимальное количество тест-кейсов, необходимых для полного покрытия кода.
  
- Определить риски. Код с большой цикломатической сложностью может быть более подвержен ошибкам.

- Принимать решение по оценке. Например, если требуется реализовать задачу или проект в неком компоненте, то можно сперва оценить ЦС этого компонента. Это поможет принять решение об оценке задачи/проекта. Если значение ЦС высокое, то, вероятно потребуется больше времени на погружение в этот компонент. Так же это будет влияние на оценку по тестированию, как было указано во 2 пункте.


Определить цикломатическую сложность можно с помощью следующей формулы:

```M = E - N + 2P```

Где:

- М - цикломатическая сложность
- Е - количество ребер в графе потока управления (то есть количество переходов между операторами кода)
- N - количество узлов в графе потока управления (то есть количество операторов кода)
- P - количество компонент связности (полностью независимых частей кода, например, отдельные подпрограммы)

Значение ЦС может быть оценено следующим образом:

- Значение 1 указывает на отсутствие ветвлений или циклов в коде. Это оптимальное значение, так как позволяет легко понять и тестировать код.

- Значение 2-4 указывает на небольшую сложность. Код может содержать некоторые ветвления и циклы, но их количество ограничено.

- Значение 5-7 указывает на умеренную сложность кода. Код может содержать несколько ветвлений, циклов и сложных участков.

- Значение 8+ указывает на высокую сложность кода. Код содержит большое количество ветвлений, циклов и сложных участков, что делает его трудным для понимания, тестирования и поддержки.

Отмечу, что если бы в программировании были такие универсалии, что по одному значению или утверждению можно сделать точный вывод - мы бы уже давно перешли в мета-программирование. Поэтому всегда есть частности. Например, код, являющийся частью низкоуровневого алгоритма, вполне может иметь высокое значение ЦС и это ок. 
Об этом как раз следующий тезис:

У цикломатической сложности есть и некоторые ограничения и недостатки. Во-первых, она не учитывает контекст и цель программного продукта. Например, некоторые программы, например, программы для космических аппаратов или приложения для медицины, требуют более высокого уровня сложности и строгих правил ветвления и циклов. Во-вторых, цикломатическая сложность не дает полной картины о других аспектах качества кода, таких как поддерживаемость, переиспользуемость и эффективность.

Тем не менее цикломатическая сложность является полезным инструментом для оценки и понимания сложности программного кода. Она помогает разработчикам принимать обоснованные решения относительно улучшения и оптимизации кода, планировать тестирование и определить потенциальные риски. Комбинирование измерения цикломатической сложности с другими методами статического и динамического анализа кода поможет создать качественное, эффективное и легко поддерживаемое программное обеспечение.

В итоге, использование метрики цикломатической сложности позволяет разработчикам принимать обоснованные решения на основе количественных данных, а не субъективных предположений. Измерение сложности кода является важным шагом в направлении создания высококачественно ПО.

**Выводы.**

Метрика цикломатической сложности является важным инструментом для измерения сложности программного кода. Она помогает разработчикам и командам разработки программного обеспечения понять уровень сложности кода, определить участки требующие оптимизации и улучшения, а также спланировать тестирование. Цикломатическая сложность позволяет принимать обоснованные решения на основе количественных данных, а не субъективных предположений.


Несколько банальных советов по работе с цикломатической сложностью:

1. В первую очередь - целесообразность рефакторинга сложного кода. Хорошо - рефакторинг часто используемого кода ради ускорения и упрощения разработки в этом компоненте. Плохо - рефакторинг ради уменьшения показателя ЦС.
2. Согласуйте пороговые значения ЦС с командой.
3. Воспринимайте ЦС, да и любую метрику, как инструмент, предоставляющий дополнительную информацию. 

Далее будут рассмотрены другие метрики кода.
